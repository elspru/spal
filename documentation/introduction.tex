\chapter{Introduction}
\begin{multicols}{2}

This is a human speakable programming language, geared for artificial general
intelligence development.

\section{Problem}
\subsection{Disglossia}

\subsubsection{Computer Languages}
In order to program all levels of a modern computer, you need to know many
different programming languages. Assembly/LLVM/SPIRV at the lowest level, C for
system programming, C++/GTK/QT for graphical interface programming,
Javascript/HTML/CSS/PHP/Perl for web programming, OpenCL/OpenMP/Pthread for parallel programming,
bash/python/ruby/node for scripting, Java/C\#/Lua for portable programming,
ansible/chef/docker/kubernetes for administration, a host of different data
storage formats XML/CSV/JSON/YAML/SQL and different documentation languages
LaTeX/Doxygen/Markdown/TexInfo just to name a few. That doesn't even include
statistics, audio, image and video processing languages.

\subsubsection{Human Languages}

You may have heard the story of Babel, and the story of Eve and the apple.
The evidence goes back much farther, to Mitochondrial Eve, in thesecond last
glaciation about 130 thousand years ago.

Mitochondrial Eve is the most successful mother, the mother all homo-sapiens
share.

Eden was the great rift valley of Africa.

Mitochondrial Eve lived during times of famine where most women were likely too
starved to be fertile.  Eve was a clan leader and got enough food to reproduce,
she had many daughters that became clan leaders. 

Human language may have been perfected by Mitochondrial Eve, she helped her clan
work together more efficiently than all the others during the population
bottleneck, and thus came out the winner.

To this day we inherit our language brain centers from the mothers side.  

Eve's daughters spread out, some went west, some, south, some east, some north.

Those that went South and East preserved clicks, like the Khoisan people of the
kalahari.
Those that went west into the jungle became the pygmies.
Those that went north eventually became the farmers, the Bantu and peoples of
the rest of the continents.

The language of Mitochondrial Eve can be reconstructed based on the common
features of the oldest languages in the world, as well as our genetic
predispositions to prefer certain forms of grammar.

The most common grammar form, and the one we are predisposed to is
subject-object-verb (SOV), or head-final with postpositions and-or suffixes.
Similar to Khoe (of the khoisan), Basque (the first homo-sapiens in Europe), 
Australian languages, Turkic (Central Asian), Uralic (North Eurasian),
Tibetan/Burmese (East Asian) and \\ Proto-Indo-European (That conquered the world).



\section{Paradigm}
\subsection{Easy to write bad code}
In most, perhaps all contemporary languages it is easy for beginners to write
bad code. 

In assembly it is easy to write tangled spaghetti code.
In C and C++ it is easy to have memory problems (buffer overflow, memory leaks,
reading unassigned variables, etc)
In Garbage collection languages it is easy to spend significant computer
resources on allocating and deallocating memory. 
In Object Oriented languages it is easy to write unscalable code (any which uses
objects).
In functional programming languages it is easy to write memory bound code
(non-tail recursive with lots of allocation and deallocation).

It often takes a lot of expertise to know the workarounds for the common
programming traps, and even harder  to apply them consistently.

\subsection{Obsolete Non-Parallel Paradigms}
Object Oriented, non-tail recursion and referentially opaque code are all
obsolete considering that GPUs and parallel hardware are where processing power
is growing the fastest.

It's easy to write bad code in many paradigms.

\section{Inspiration}
I was mentally projecting myself into a robot host body one day and realized
that it would take a superhuman Artificial intelligence to be proficient in all 
of the languages and protocols of a modern computer and their interactions.

And I came to the realization that I wanted to be able to have access to all my
knowledge and abilities with one language. 


\section{Answer}

The answer I came up with is the speakable programming language.

\subsection{Vocabulary}

The root vocabulary was generated by taking the most frequently used
thirty-eight thousand English words, translating them into the top thirty to
forty human languages, and then removing words that were ambiguous and-or
homophones.

This left a remainder of about eight thousand words, which were common to all
languages and orthogonal (not overlapping in meaning). 

This way you can use the root words of your preferred language to program, and
they will be translated to all the other languages. 

\subsection{Grammar}
SPAL currently uses Eve's grammar:
 SOV with postpositions and-or affixes is the grammar of Pyash 
the base language of SPAL.\@

Transferring it to other forms of grammar is fairly straight forward. And has
been done with a former iteration of this language. That does however lead to a
large number of variants. 

So for the near future, will simply have Eve's grammar, and your preferred
vocabulary for root words.  

Many contemporary languages lost the nominative-accusative case distinction, and
have grammar words which are used ambigiously. For example, the word ``with'' in
English is used for comitative-case and instrumental-case. 

So for the actual grammar words, have decided to go with abbreviated forms of the
translations of glossing abbreviations. For example \_com for comitative-case and
\_ins for instrumental case. 

Because of knowledge bias, we'll have to work together to create documentation 
that is easy for beginners to understand.

\subsection{Paradigm}

The paradigm conforms to the JPL ten
commandments\cite{JPL10}.

\begin{itemize}
\item Restrict all code to very simple control flow constructs – do not use goto
statements, setjmp or longjmp constructs, and direct or indirect 
recursion. 
\item All loops must have a fixed upper-bound. It must be trivially possible for
a checking tool to prove statically that a preset upper-bound on the number of
iterations of a loop cannot be exceeded. If the loop-bound cannot be proven
statically, the rule is considered violated.  
\item Do not use dynamic memory allocation after initialization.  
\item No function should be longer than what can be printed on a single sheet of
paper in a standard reference format with one line per statement and one line
per declaration. Typically, this means no more than about 60 lines of code per
function. 
\item The assertion density of the code should average to a minimum of two
assertions per function. Assertions are used to check for anomalous conditions
that should never happen in real-life executions. Assertions must always be
side-effect free and should be defined as Boolean tests. When an assertion
fails, an explicit recovery action must be taken, e.g., by returning an error
condition to the caller of the function that executes the failing assertion. Any
assertion for which a static checking tool can prove that it can never fail or
never hold violates this rule. (I.e., it is not possible to satisfy the rule by
adding unhelpful `` assert (true) '' statements.)  


\item Variables must be declared at the smallest possible level of scope. All
arrays must have a max-length variable, and bounds of all new index points must
be checked before a read or write operation occurs.  If an array is
uninitialized, there must be an initialized-length variable also, so
uninitialized data is not read accidentally. 
\item The return value of non-void functions must be checked by each calling 
function, and the validity of parameters must be checked inside each function. 
\item The use of the preprocessor must be limited to the inclusion of header files and 
simple macro definitions.  
\item The use of pointers should be restricted. Specifically, no more than one
level of dereferencing is allowed. Pointer dereference operations may not be
hidden in macro definitions or inside typedef declarations. Function pointers
are not permitted.
\item All code must be compiled, from the first day of development, with all
compiler warnings enabled at the compiler’s most pedantic setting. All code must
compile with these setting without any warnings. All code must be checked daily
with at least one, but preferably more than one, state-of-the-art static source
code analyzer and should pass the analyses with zero warnings.  
\end{itemize}

Additionally some OpenCL restrictions.
\begin{itemize}
\item no return values.
\item input parameters are constants.
\item output parameters are pointers. 
\item functions that don't interact with environment are referentially
        transparent.
\end{itemize}

Those should all be taken care of automatically, when compiling from Pyash to
OpenCL C.
So while other programming features may be available, it would take extra effort
to enable the program to use them, and thus to write bad code. 
\end{multicols}
